<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>test</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      background: #222;
    }
    /* 5個のリールを横並びにするコンテナ */
    .slots-container {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }
    /* 各スロット枠：カードサイズ200×200に合わせる */
    .slot {
      /*width: 210px; */  /* 200pxカード幅 + 10px余裕 */

width: 300px;

      height: 400px;
      overflow: hidden;
      border: 3px solid #fff;
      position: relative;
      background: black;
      perspective: 800px;
    }
    /* 画像リスト */
    .slot-inner {
      display: flex;
      position: absolute;
      top: 0;
      left: 0;
    }
    /* 各カード：サイズ200×200、余白20px */
    .card {
      width: 300px;
      height: 400px;
      /* margin-right: 20px;*/
    margin-right: 0px;
 margin-left: 0px;

      transform-origin: center center;
    }
    button {
      padding: 10px 20px;
      font-size: 18px;
      cursor: pointer;
    }
  </style>




  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
    }
    .particle {
      position: absolute;
      width: 20px;
      height: 20px;
      background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(255,200,100,0.8) 50%, rgba(255,255,255,0) 100%);
      clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
      pointer-events: none;
      opacity: 1;
    }
  </style>

</head>
<body>


  <div id="particle-container"></div>



  <!-- 5個のリールを横並びに配置 -->
  <div class="slots-container">


    <div class="slot">
      <div class="slot-inner">
        <img src="a.jpg" class="card">
        <img src="b.jpg" class="card">
        <img src="c.jpg" class="card">
        <img src="d.jpg" class="card">
        <img src="e.jpg" class="card">
        <img src="a.jpg" class="card">
        <img src="b.jpg" class="card">
        <img src="c.jpg" class="card">
        <img src="d.jpg" class="card">
        <img src="e.jpg" class="card">
        <img src="a.jpg" class="card">
        <img src="b.jpg" class="card">
        <img src="c.jpg" class="card">
        <img src="d.jpg" class="card">
        <img src="e.jpg" class="card">
      </div>
    </div>


    <div class="slot">
      <div class="slot-inner">
        <img src="a.jpg" class="card">
        <img src="b.jpg" class="card">
        <img src="c.jpg" class="card">
        <img src="d.jpg" class="card">
        <img src="e.jpg" class="card">
        <img src="a.jpg" class="card">
        <img src="b.jpg" class="card">
        <img src="c.jpg" class="card">
        <img src="d.jpg" class="card">
        <img src="e.jpg" class="card">
        <img src="a.jpg" class="card">
        <img src="b.jpg" class="card">
        <img src="c.jpg" class="card">
        <img src="d.jpg" class="card">
        <img src="e.jpg" class="card">
      </div>
    </div>

        <div class="slot">
      <div class="slot-inner">
        <img src="a.jpg" class="card">
        <img src="b.jpg" class="card">
        <img src="c.jpg" class="card">
        <img src="d.jpg" class="card">
        <img src="e.jpg" class="card">
        <img src="a.jpg" class="card">
        <img src="b.jpg" class="card">
        <img src="c.jpg" class="card">
        <img src="d.jpg" class="card">
        <img src="e.jpg" class="card">
        <img src="a.jpg" class="card">
        <img src="b.jpg" class="card">
        <img src="c.jpg" class="card">
        <img src="d.jpg" class="card">
        <img src="e.jpg" class="card">
      </div>
    </div>

        <div class="slot">
      <div class="slot-inner">
        <img src="a.jpg" class="card">
        <img src="b.jpg" class="card">
        <img src="c.jpg" class="card">
        <img src="d.jpg" class="card">
        <img src="e.jpg" class="card">
        <img src="a.jpg" class="card">
        <img src="b.jpg" class="card">
        <img src="c.jpg" class="card">
        <img src="d.jpg" class="card">
        <img src="e.jpg" class="card">
        <img src="a.jpg" class="card">
        <img src="b.jpg" class="card">
        <img src="c.jpg" class="card">
        <img src="d.jpg" class="card">
        <img src="e.jpg" class="card">
      </div>
    </div>

        <div class="slot">
      <div class="slot-inner">
        <img src="a.jpg" class="card">
        <img src="b.jpg" class="card">
        <img src="c.jpg" class="card">
        <img src="d.jpg" class="card">
        <img src="e.jpg" class="card">
        <img src="a.jpg" class="card">
        <img src="b.jpg" class="card">
        <img src="c.jpg" class="card">
        <img src="d.jpg" class="card">
        <img src="e.jpg" class="card">
        <img src="a.jpg" class="card">
        <img src="b.jpg" class="card">
        <img src="c.jpg" class="card">
        <img src="d.jpg" class="card">
        <img src="e.jpg" class="card">
      </div>
    </div>





  </div>
  <button id="startButton">start</button>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.3/gsap.min.js"></script>
  <script>
    // helper: modNeg() を使って x を常に -totalWidth ～ 0 の範囲に収める
    function modNeg(x, m) {
      return ((x % m) + m) % m - m;
    }
    
    // 共通パラメータ
    // カードサイズ＋余白: 200px + 20px = 220px
    //const cardWidth = 220; 
    const cardWidth = 300; 
    const numCards = 5; // 5種類のカード
    const totalWidth = cardWidth * numCards; // 220 * 5 = 1100px
    // スロット枠は幅210px → 中央は105px
    
    // 各リールの情報を保持する配列
    const reels = [];
    const slotElements = document.querySelectorAll('.slot');
    slotElements.forEach(slot => {
      const reel = slot.querySelector('.slot-inner');
      reels.push({
        reel: reel,
        tween: null,
        targetIndex: null,
        stopped: false
      });
      
      // 初期化時に円柱風エフェクトを適用
      updateCylindricalTransform(reel);
    });
    
    const button = document.getElementById('startButton');
    let isRunning = false;
    
    // 円柱風変形：各カードに rotateY と scale を適用
    function updateCylindricalTransform(reel) {
      //const slotCenter = 105; // スロットの中央
 const slotCenter = 200; // スロットの中央
      const cards = reel.querySelectorAll('.card');
      let currentX = gsap.getProperty(reel, "x") || 0;
      
      // すべてのカードを処理（両方のセット）
      cards.forEach((card, index) => {
        let cardX = currentX + index * cardWidth;
        let cardCenter = cardX + cardWidth / 2;
        let diff = cardCenter - slotCenter;
        let normalized = diff / (slotCenter * 1.5); // 視野角を調整
        
        // 値を -1 から 1 の範囲に収める
        normalized = Math.max(-1, Math.min(1, normalized));
        
        const maxAngle = 35; // 最大回転角度35°
        let angle = normalized * maxAngle;
        
        // スケールを調整（中央は1、端は約0.8）
        let scale = 1 - 0.2 * Math.abs(normalized);
        
        // 透明度も追加（完全に見えなくならないよう最小値を設定）
        let opacity = 1 - 0.5 * Math.abs(normalized);
    

        gsap.set(card, {
          transform: `rotateY(${angle}deg) scale(${scale})`,
          opacity: opacity
        });
      });
    }
    




    // 各リールの回転開始
    function startReels() {
      if (isRunning) return;
      isRunning = true;
      button.disabled = true;
      


      reels.forEach(reelObj => {
        // 各リールでランダムに chosen カード（0〜4）を決定
        reelObj.targetIndex = Math.floor(Math.random() * numCards);
        reelObj.stopped = false;
        

//reelObj.targetIndex = 4;


        // 現在のアニメーションを停止
        if (reelObj.tween) reelObj.tween.kill();
        
        // 初期位置を設定（モジュロの範囲内に）
        let currentX = gsap.getProperty(reelObj.reel, "x") || 0;

currentX = 0;

        currentX = modNeg(currentX, totalWidth);
        gsap.set(reelObj.reel, { x: currentX });
        
        // 新しいアニメーションを開始
        reelObj.tween = gsap.to(reelObj.reel, {
          x: `-=${totalWidth * 3}`, // 3周分回転
          duration: 2.0,
          ease: "linear",
          repeat: -1,
          modifiers: {
            x: (x) => `${modNeg(parseFloat(x), totalWidth)}px`
          },
          onUpdate: () => updateCylindricalTransform(reelObj.reel)
        });
      });
      
      // 左から順に、600msずつ遅れて各リールを停止
      reels.forEach((reelObj, i) => {
        setTimeout(() => stopReel(reelObj), 3000 + i * 600);
      });
    }
    
    // 各リールの停止処理
    function stopReel(reelObj) {
      if (!reelObj.tween) return;
      
      // 現在のアニメーションを停止
      reelObj.tween.kill();
      reelObj.tween = null;
      
      // 現在位置を正規化
      let currentX = gsap.getProperty(reelObj.reel, "x");
      currentX = modNeg(currentX, totalWidth);
      

//console.log("currentX : " + currentX); 

      // 目標位置：選択されたカードがスロットの中央に表示されるよう調整
      // スロット中央(105px)にカードの中央(100px)が来るよう計算
      // 105 - 100 = 5px オフセット
      //let finalTarget = 5 - reelObj.targetIndex * cardWidth;
      let finalTarget =  reelObj.targetIndex * cardWidth;

      // 常に前方に進むよう距離を計算
      let distanceToTarget = finalTarget - currentX;
      if (distanceToTarget > 0) {
        finalTarget -= totalWidth;
        distanceToTarget = finalTarget - currentX;
      }
      
      // 距離が短すぎる場合はもう1周
      if (Math.abs(distanceToTarget) < cardWidth * 2) {
        finalTarget -= totalWidth;
      }
    
      // ゆらし効果の確率（targetIndexが大きいほど高確率）
      let overshootProbability = 0.3 + 0.1 * reelObj.targetIndex;
      
   if (Math.random() < overshootProbability) {
//if (true) {

        // オーバーシュートするセル数（2〜4）
        //let overshootCells = 2 + Math.floor(Math.random() * 1);


//let overshootCells = 1 - Math.floor(Math.random() * 2);


let overshootCells = 1 -  Math.floor(Math.random() * 3);

//overshootCells = -1;


//console.log(    overshootCells ); 



        // 最終位置からovershootCells分先
        let newFinalTarget = finalTarget - overshootCells * cardWidth;
        
        // タイムラインでチェーンアニメーション
        let tl = gsap.timeline({
          onUpdate: () => updateCylindricalTransform(reelObj.reel),
          onComplete: () => {
            reelObj.stopped = true;
            checkAllStopped();
          }
        });
        

        /*
        // まず低速状態に移行
        tl.to(reelObj.reel, {
          x: newFinalTarget + cardWidth * 0.7, // 70%地点まで
          duration: 1.8,
          ease: "slow(0.5, 0.3, false)"
        })
        // さらに低速で戻る
        .to(reelObj.reel, {
          x: finalTarget,
          duration: 1.0,
          ease: "power1.inOut"
        });
        */

let add = 0;
if(overshootCells == 1)
  add = cardWidth * 0.5;
else if(overshootCells == -1)
add = cardWidth * -0.5;

        // まず低速状態に移行
        tl.to(reelObj.reel, {
          x: newFinalTarget + add, 
          //x: newFinalTarget + cardWidth * 0.5, // 70%地点まで
          duration: 1.8,
          ease: "slow(0.5, 0.3, false)",
        })
        // さらに低速で戻る
        .to(reelObj.reel, {
          x: finalTarget,
          duration: 1.0,
          ease: "power1.inOut",
           delay: 0.5
        });
   

      } else {
        // 通常停止（減速して止まる）
        gsap.to(reelObj.reel, {
          x: finalTarget,
          duration: 1.5,
          ease: "power2.out",
          onUpdate: () => updateCylindricalTransform(reelObj.reel),
          onComplete: () => {
            reelObj.stopped = true;
            checkAllStopped();
          }
        });
      }











    }
    
    // すべてのリールが停止したか確認
    function checkAllStopped() {
      if (reels.every(r => r.stopped)) {
        isRunning = false;
        button.disabled = false;
      }
    }
    
    // 初期化（すべてのリールに円柱風エフェクトを適用）
    reels.forEach(reelObj => {
      updateCylindricalTransform(reelObj.reel);
    });
    
    button.addEventListener("click", startReels);
  </script>








<script>
  // パーティクル用コンテナ
  const particleContainer = document.getElementById("particle-container");

  function createParticle() {
    const wrapper = document.createElement("div");
    wrapper.style.position = "absolute";
    wrapper.style.pointerEvents = "none";
    
    const baseParticle = document.createElement("div");
    baseParticle.classList.add("particle");

    // 🔹 360° ランダムな角度で回転
    const randomRotation = Math.random() * 360;
    baseParticle.style.transform = `rotate(${randomRotation}deg)`;
    
    wrapper.appendChild(baseParticle);
    particleContainer.appendChild(wrapper); 

    // 初期位置（画面下全体）
    const startX = Math.random() * window.innerWidth - 100;
    const startY = window.innerHeight + 10;
    wrapper.style.left = `${startX}px`;
    wrapper.style.top = `${startY}px`;

    // ランダムな移動方向（右上へ向かう）
    const targetX = startX + Math.random() * 200 + 100;
    const targetY = startY - (window.innerHeight * 0.8);
    
    const duration = Math.random() * 3 + 5; // 移動の全体時間

    // 🔹 メインのパーティクル（ゆっくり消える）
    gsap.to(baseParticle, {
      x: targetX - startX,
      y: targetY - startY,
      scale: Math.random() * 1.5 + 0.5,
      opacity: 0,
      duration: duration,
      ease: "power1.out",
    });

    // 🔹 瞬くエフェクト（2重構造の外側）
    gsap.to(wrapper, {
      opacity: Math.random() * 0.5 + 0.2 , // 0.3～0.8の範囲で変化
      duration: Math.random() * 0.5+ 0.2 , // 0.3～0.8秒で変化
      repeat: Math.floor(duration / 0.8), // 持続時間に合わせた回数で繰り返す
      yoyo: true, // 行ったり来たり（瞬きする感じ）
      ease: "power1.inOut",
    });

gsap.to(baseParticle, {
  filter: `hue-rotate(${Math.random() * 60 + 30}deg)`, // ±30度の範囲で色相を変える
  duration: Math.random() * 0.8 + 0.5, // 色変化の時間
  repeat: Math.floor(duration / 1), // 持続時間に合わせた回数で繰り返す
  yoyo: true, // 行ったり来たり（色が交互に変わる）
  ease: "power1.inOut",
});


  }

  function startParticleEffect() {
    setInterval(createParticle, 100);
  }

  startParticleEffect();
</script>








</body>





</html>


